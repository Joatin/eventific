{"version":3,"file":"Event.js","sourceRoot":"","sources":["../../src/Event.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,+CAAkE;AAElE,yBAA2B;AAE3B,mCAAkC;AAElC;;;;GAIG;AACH;IAAA;IAOA,CAAC;IAAD,oBAAC;AAAD,CAAC,AAPD,IAOC;AAPqB,sCAAa;AAcnC;;;;;GAKG;AACH,sBAA6B,OAA4B;IACvD,MAAM,CAAC,UAAsC,KAAQ;QACnD,MAAM;gBAAe,2BAAK;gBAWxB;oBAAY,cAAc;yBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;wBAAd,yBAAc;;oBAA1B,+BACW,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,UAE7B;oBAPM,WAAK,GAAG,OAAO,CAAC,KAAK,CAAC;oBAM3B,KAAI,CAAC,OAAO,GAAI,IAAI,CAAC,CAAC,CAAc,CAAC,GAAG,CAAS,eAAM,CAAC,CAAC;;gBAC3D,CAAC;gBAbM,gCAAwB,GAA/B,UAAgC,cAAwB;oBACtD,IAAM,QAAQ,GAAG,cAAc,CAAC,gBAAgB,EAAE,CAAC;oBACnD,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC5B,CAAC;gBAcK,oCAAkB,GAAxB,UAAyB,KAAwB,EAAE,KAAU;;;;;;oCACvD,MAAM,GAAG,iCAAkB,CAAC;oCAChC,EAAE,CAAA,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;wCAClB,MAAM,GAAG,iCAAkB,CAAC,IAAI,CAAC;4CAC/B,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE;yCACnC,CAAC,CAAC;oCACL,CAAC;oCAAC,IAAI,CAAC,CAAC;wCACN,MAAM,GAAG,iCAAkB,CAAC,IAAI,CAAC;4CAC/B,OAAO,EAAE,GAAG,CAAC,GAAG,EAAE;yCACnB,CAAC,CAAC;oCACL,CAAC;oCACD,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;yCACvB,IAAI,CAAC,MAAM,EAAX,wBAAW;oCACL,qBAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,EAAA;wCAAtC,sBAAO,SAA+B,EAAC;;oCAEvC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,yBAAsB,IAAI,CAAC,KAAK,4BAAwB,CAAC,CAAC;oCAC7E,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;;;;iBAEvC;gBACH,cAAC;YAAD,CAAC,AArCM,CAAc,KAAK;YAKV,OAAI,GAAG,OAAQ;YACf,QAAK,GAAG,OAAO,CAAC,KAAM;eA+BpC;;IACJ,CAAC,CAAC;AACJ,CAAC;AAzCD,oCAyCC","sourcesContent":["import { options, Schema } from 'joi';\nimport { EventMessage, eventMessageSchema } from './EventMessage';\nimport { Injector } from './Injector';\nimport * as Joi from 'joi';\nimport { IAggregate } from './Aggregate';\nimport { Logger } from './Logger';\n\n/**\n * OBS: Needed until typescript supports decorator type extensions.\n *\n * @since 1.0.0\n */\nexport abstract class IEventHandler<T, R> {\n  public static _InstantiateEventHandler: (injector: Injector) => IEventHandler<any, any>;\n  public static Type: string;\n  public static Event: string;\n  public readonly event: string;\n  public abstract handle(event: EventMessage<T>, state: R): Promise<R>;\n  _validateAndHandle: (event: EventMessage<T>, state: R) => Promise<R>;\n}\n\nexport interface EventHandlerOptions {\n  event: string;\n  schema?: Schema;\n}\n\n/**\n * Creates a new event.\n *\n * @since 1.0.0\n * @returns {IEventHandler<any>} A decorated class that implements IEvent\n */\nexport function EventHandler(options: EventHandlerOptions) {\n  return <T extends {new(...args: any[]): {}}>(Class: T) => {\n    return class extends Class {\n      static _InstantiateEventHandler(parentInjector: Injector): IEventHandler<any, any> {\n        const injector = parentInjector.newChildInjector();\n        return new this(injector);\n      }\n      public static Type = 'Event';\n      public static Event = options.event;\n      public event = options.event;\n\n      _logger: Logger;\n\n      constructor(...args: any[]) {\n        super(...args[0].args(Class));\n        this._logger = (args[0] as Injector).get<Logger>(Logger);\n      }\n\n      handle: (event: EventMessage<any>, state: any) => Promise<any>;\n\n      async _validateAndHandle(event: EventMessage<any>, state: any): Promise<any> {\n        let schema = eventMessageSchema;\n        if(options.schema) {\n          schema = eventMessageSchema.keys({\n            content: options.schema.required()\n          });\n        } else {\n          schema = eventMessageSchema.keys({\n            content: Joi.any()\n          });\n        }\n        Joi.assert(event ,schema);\n        if(this.handle) {\n          return await this.handle(event, state);\n        } else {\n          this._logger.error(`The event handler \"${this.event}\" has no handle method`);\n          throw new Error('No handle method');\n        }\n      }\n    };\n  };\n}\n"]}