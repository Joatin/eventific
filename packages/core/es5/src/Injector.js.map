{"version":3,"file":"Injector.js","sourceRoot":"","sources":["../../src/Injector.ts"],"names":[],"mappings":"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","sourcesContent":["import 'reflect-metadata';\nimport * as assert from 'assert';\n\nexport interface ClassDependencyDefinition {\n  provide?: string | symbol | Function;\n  useClass: Function;\n  dynamic?: true;\n}\n\nexport interface ValueDependencyDefinition {\n  provide: string | symbol | Function;\n  useConstant: any;\n}\n\nexport class Injector {\n  private _parent?: Injector;\n  private _dependencies = new Map<string | symbol, ClassDependencyDefinition | ValueDependencyDefinition>();\n\n  constructor(\n    parent?: Injector\n  ) {\n    this._parent = parent;\n  }\n\n  public set(dependency: ClassDependencyDefinition | ValueDependencyDefinition | {new(...args: any[]): {}}): void {\n    if((<ClassDependencyDefinition>dependency).useClass) {\n      assert(isClass((<ClassDependencyDefinition>dependency).useClass), 'The provided class has to actually be a class');\n      if((<ClassDependencyDefinition>dependency).provide) {\n        const key = this._getProvideKey((<ClassDependencyDefinition>dependency).provide);\n        this._dependencies.set(key, (<ClassDependencyDefinition>dependency));\n      } else {\n        this._dependencies.set((<ClassDependencyDefinition>dependency).useClass.name, (<ClassDependencyDefinition>dependency))\n      }\n    } else if((<ValueDependencyDefinition>dependency).useConstant) {\n      const key = this._getProvideKey((<ValueDependencyDefinition>dependency).provide);\n      this._dependencies.set(key, (<ValueDependencyDefinition>dependency));\n    } else {\n      assert(isClass((<{new(...args: any[]): {}}>dependency)), 'The provided class has to actually be a class');\n      this._dependencies.set((<{new(...args: any[]): {}}>dependency).name, {useClass: (<{new(...args: any[]): {}}>dependency)})\n    }\n  }\n\n  public get<T = any>(type: string | symbol | Function): T {\n    const result = this.getOptional<T>(type);\n    if(result) {\n      return result;\n    } else {\n      throw new Error('InjectionError: No provider for type: ' + type.toString());\n    }\n  }\n\n  public getOptional<T = any>(type: string | symbol | Function): T | undefined {\n    const key = this._getProvideKey(type);\n    let result = this._dependencies.get(key);\n    if(!result && this._parent) {\n      return this._parent.getOptional<T>(type);\n    } else if(result) {\n      if((<ClassDependencyDefinition>result).useClass) {\n        return new ((<ClassDependencyDefinition>result).useClass as any)(...this.args((<ClassDependencyDefinition>result).useClass)) as T\n      } else {\n        return (<ValueDependencyDefinition>result).useConstant as any;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  public args(type: Function): any[] {\n    const types = this._getTypes(type);\n    const args: any[] = [];\n    types.forEach((param) => {\n      if(param.required) {\n        args.push(this.get(param.type));\n      } else {\n        args.push(this.getOptional(param.type));\n      }\n    });\n    return args;\n  }\n\n  private _getTypes(type: Function) {\n    assert.notEqual(type, undefined);\n    const definedTypes = Reflect.getMetadata('injector:params', type) || [];\n    const params: any[] = Reflect.getMetadata(\"design:paramtypes\", type) || [];\n    const types = new Array(params.length);\n    params.forEach((param: Function, index: number) => {\n      types[index] = {\n        required: true,\n        type: param.name\n      }\n    });\n    definedTypes.forEach((def: any) => {\n      if(def.index >= params.length) {\n        throw new Error('InjectionError: injector:params has defined a param that has a greater index than the total amount of params');\n      }\n      types[def.index] ={\n        required: def.required,\n        type: def.type\n      }\n    });\n\n    types.forEach((param, index) => {\n      if(\n        param.type === 'Number' ||\n        param.type === 'String' ||\n        param.type === 'Boolean' ||\n        param.type === 'Object' ||\n        param.type === 'Array' ||\n        param.type === 'Function' ||\n        param.type === 'Object'\n      ) {\n        throw new Error(`InjectionError: param at index: ${index} on type ${type.name} is of a basic type and does not have a @Inject annotation`);\n      }\n    });\n\n    return types;\n  }\n\n  private _getProvideKey(provide: any) {\n    const type = typeof provide;\n    switch(type) {\n      case 'string': {\n        return provide;\n      }\n      case 'number': {\n        throw new Error('InjectionError: Numbers are not a supported provide type')\n      }\n      case 'boolean': {\n        throw new Error('InjectionError: Booleans are not a supported provide type')\n      }\n      case 'function': {\n        return provide.name\n      }\n      default: {\n        throw new Error(`InjectionError: ${type} are not a supported provide type`)\n      }\n    }\n  }\n\n  public newChildInjector(): Injector {\n    return new Injector(this);\n  }\n}\n\nfunction isClass(v: any) {\n  // return typeof v === 'function' && /^\\s*class\\s+/.test(v.toString());\n  return typeof v === 'function';\n}\n"]}