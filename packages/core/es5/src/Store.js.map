{"version":3,"file":"Store.js","sourceRoot":"","sources":["../../src/Store.ts"],"names":[],"mappings":";;;;;;;;;;;;AASA;;;;GAIG;AACH;IAAA;IA2BA,CAAC;IAAD,aAAC;AAAD,CAAC,AA3BD,IA2BC;AA3BqB,wBAAM;AAiC5B;;;;;GAKG;AACH,eAAsB,OAAqB;IACzC,MAAM,CAAC,UAAsC,KAAQ;QACnD,MAAM;gBAAe,2BAAK;gBAAnB;oBAAA,qEAON;oBALC,UAAI,GAAG,OAAO,CAAC,IAAI,CAAC;;gBAKtB,CAAC;gBAHQ,oBAAY,GAAnB,UAAoB,QAAkB;oBACpC,MAAM,MAAK,IAAI,YAAJ,IAAI,kBAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,MAAC;gBAC1C,CAAC;gBACH,cAAC;YAAD,CAAC,AAPM,CAAc,KAAK;YACjB,OAAI,GAAG,OAAO,CAAC,IAAK;eAM5B;;IACH,CAAC,CAAC;AACJ,CAAC;AAXD,sBAWC","sourcesContent":["import { EventMessage } from './EventMessage';\nimport { Snapshot } from './Snapshot';\nimport { Injector } from './Injector';\n\nexport interface GetEventsResult<T> {\n  events: EventMessage[];\n  snapshot?: Snapshot<T>;\n}\n\n/**\n * A interface for event stores.\n *\n * @since 1.0.0\n */\nexport abstract class IStore {\n  static _CreateStore: (injector: Injector) => IStore;\n  static Settings: (settings: any) => { _CreateStore: (injector: Injector) => IStore };\n\n  /**\n   * Starts this event store instance\n   *\n   * @since 1.0.0\n   *\n   * @returns {Promise<any>} A promise that returns when the store is ready\n   */\n  public abstract start(): Promise<any>;\n\n  /**\n   * Returns the events for the particular aggregate. The result might also contain a snapshot.\n   *\n   * @since 1.0.0\n   *\n   * @param {string} aggregateName The name of the aggregate to access\n   * @param {string} aggregateId The id of the particular aggregate\n   * @returns {Promise<GetEventsResult>} A promise that resolves with events and perhaps a snapshot.\n   */\n  public abstract getEvents<T>(aggregateName: string, aggregateId: string): Promise<GetEventsResult<T>>;\n\n  public abstract applyEvents<T>(aggregateName: string, events: EventMessage[], state?: T): Promise<void>;\n  public abstract purgeAllSnapshots(aggregateName: string): Promise<void>;\n  public abstract onEvent(aggregateName: string, eventName: string | null, callback: (event: EventMessage) => void): void;\n}\n\nexport interface StoreOptions {\n  name: string;\n}\n\n/**\n * Store decorator\n * @param {StoreOptions} options\n * @returns {<T extends {new(...args: any[]) => {}}>(Class: T) => T}\n * @constructor\n */\nexport function Store(options: StoreOptions) {\n  return <T extends {new(...args: any[]): {}}>(Class: T): T => {\n    return class extends Class {\n      static Name = options.name;\n      name = options.name;\n\n      static _CreateStore(injector: Injector) {\n        return new this(...injector.args(Class))\n      }\n    }\n  };\n}\n"]}