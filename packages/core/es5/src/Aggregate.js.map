{"version":3,"file":"Aggregate.js","sourceRoot":"","sources":["../../src/Aggregate.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yBAA2B;AAC3B,+BAAiC;AACjC,+BAA0B;AAG1B,mDAAwE;AAIxE,iCAAwC;AACxC,mCAAkC;AAClC,mDAAkD;AAClD,+CAAkE;AAElE,IAAM,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AAkC1C;;;;GAIG;AACH;IAAA;IAwBA,CAAC;IAAD,iBAAC;AAAD,CAAC,AAxBD,IAwBC;AAxBqB,gCAAU;AA0BhC,mBAA0B,OAAyB;IACjD,MAAM,CAAC,UAAsC,KAAQ;QACnD,MAAM;gBAAe,2BAAK;gBAkBxB;oBAAY,cAAc;yBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;wBAAd,yBAAc;;oBAA1B,+BACY,IAAI,CAAC,CAAC,CAAc,CAAC,IAAI,CAAC,KAAK,CAAC,UAa3C;oBA7BM,UAAI,GAAG,OAAO,CAAC,IAAI,CAAC;oBAkBzB,KAAI,CAAC,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;oBACzB,KAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAC,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,KAAI,EAAC,CAAC,CAAC;oBAE5D,KAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,eAAe,CAAC,GAAG,CAAsC,UAAC,GAAG,IAAK,OAAA,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,0BAA0B,CAAC,KAAI,CAAC,SAAS,CAAC,CAAC,EAA7D,CAA6D,CAAC,CAAC,CAAC;oBAC1K,KAAI,CAAC,cAAc,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAoC,UAAC,GAAG,IAAK,OAAA,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,wBAAwB,CAAC,KAAI,CAAC,SAAS,CAAC,CAAC,EAAzD,CAAyD,CAAC,CAAC,CAAC;oBAEhK,KAAI,CAAC,OAAO,GAAG,KAAI,CAAC,SAAS,CAAC,GAAG,CAAS,eAAM,CAAC,CAAC;oBAClD,KAAI,CAAC,MAAM,GAAG,KAAI,CAAC,SAAS,CAAC,GAAG,CAAS,aAAK,CAAC,CAAC;oBAEhD,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,6BAA2B,KAAK,CAAC,IAAI,CAAC,KAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAG,CAAC,CAAC;oBAC1G,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,+BAA6B,KAAK,CAAC,IAAI,CAAC,KAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAG,CAAC,CAAC;;gBAChH,CAAC;gBA3BM,6BAAqB,GAA5B,UAA6B,cAAwB;oBACnD,MAAM,CAAC,cAAc,CAAC,CAAC;oBACvB,IAAM,QAAQ,GAAG,cAAc,CAAC,gBAAgB,EAAE,CAAC;oBACnD,QAAQ,CAAC,GAAG,CAAC,EAAC,OAAO,EAAE,eAAM,EAAE,WAAW,EAAE,IAAI,+BAAc,CAAC,eAAK,CAAC,MAAM,CAAI,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,cAAW,CAAC,CAAC,EAAC,CAAC,CAAC;oBACvH,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC5B,CAAC;gBAwBY,+BAAa,GAA1B,UAA2B,cAA8B;;;;;wCACvB,qBAAM,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,EAAA;;oCAArE,uBAAuB,GAAG,SAA2C;oCACrE,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;oCACvD,qBAAM,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,WAAW,CAAC,EAAA;;oCAAtE,WAAW,GAAG,SAAwD;yCACzE,OAAO,EAAP,wBAAO;oCACO,qBAAM,OAAO,CAAC,MAAM,CAAC,uBAAuB,EAAE,WAAW,CAAC,KAAK,EAAE,WAAW,CAAC,OAAO,CAAC,EAAA;;oCAA9F,MAAM,GAAG,SAAqF;oCACpG,EAAE,CAAA,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;wCACjC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,iCAA+B,uBAAuB,CAAC,OAAO,4EAAyE,CAAC,CAAC;wCAC5J,MAAM,KAAK,CAAC,uBAAuB,CAAC,CAAC;oCACvC,CAAC;oCACD,8BAA8B;oCAC9B,qBAAM,IAAI,CAAC,YAAY,CAAC,EAAC,KAAK,EAAE,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,WAAW,CAAC,OAAO,EAAC,EAAE,MAAM,CAAC,EAAA;;oCADzF,8BAA8B;oCAC9B,SAAyF,CAAC;oCAC1F,qBAAM,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,EAAA;;oCAAhD,SAAgD,CAAC;;;oCAEjD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,kCAA+B,uBAAuB,CAAC,OAAO,OAAG,CAAC,CAAC;oCACtF,MAAM,KAAK,CAAC,qBAAmB,uBAAuB,CAAC,OAAS,CAAC,CAAC;;;;;iBAErE;gBAEY,8BAAY,GAAzB,UAA0B,QAAuC,EAAE,MAAsB;;;;;;oCACjF,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,UAAC,EAAE,EAAE,EAAE,IAAK,OAAA,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,EAAvB,CAAuB,CAAC,CAAC;oCAClE,KAAK,GAAQ,QAAQ,CAAC,KAAK,CAAC;oCAC5B,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;0CACA,EAAZ,6BAAY;;;yCAAZ,CAAA,0BAAY,CAAA;oCAArB,KAAK;oCACb,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,iCAAkB,CAAC,CAAC;oCACtC,EAAE,CAAA,CAAE,KAAK,KAAK,IAAI,IAAI,KAAK,CAAC,OAAO,IAAI,CAAE,CAAC,CAAA,CAAC;wCACzC,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;oCAC5E,CAAC;oCACD,EAAE,CAAA,CAAE,KAAK,CAAC,OAAO,IAAI,OAAO,GAAG,CAAE,CAAC,CAAC,CAAC;wCAClC,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;oCAChE,CAAC;oCACK,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;yCAClD,OAAO,EAAP,wBAAO;;oCAEH,qBAAM,OAAO,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,EAAA;;oCADnD,KAAK,qCACA,SAA8C,GAClD,CAAC;oCACF,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;;wCAExB,MAAM,IAAI,KAAK,CAAC,+BAA6B,KAAK,CAAC,KAAO,CAAC,CAAA;;oCAf5C,IAAY,CAAA;;wCAmB/B,sBAAO,EAAC,OAAO,SAAA,EAAE,KAAK,OAAA,EAAC,EAAC;;;;iBACzB;gBAEY,0BAAQ,GAArB,UAAsB,WAAmB;;;;;wCACnB,qBAAM,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,CAAC,EAAA;;oCAAjE,WAAW,GAAG,SAAmD;oCACnE,KAAK,GAAQ,IAAI,CAAC;oCAClB,OAAO,GAAW,CAAC,CAAC,CAAC;oCACzB,EAAE,CAAA,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;wCACxB,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,KAAK,IAAI,KAAK,CAAC;wCAC5C,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,OAAO,IAAI,OAAO,CAAC;oCACpD,CAAC;oCACM,qBAAM,IAAI,CAAC,YAAY,CAAC,EAAC,KAAK,OAAA,EAAE,OAAO,SAAA,EAAC,EAAE,WAAW,CAAC,MAAM,CAAC,EAAA;wCAApE,sBAAO,SAA6D,EAAC;;;;iBACtE;gBAEM,+BAAa,GAApB;oBACE,MAAM,CAAC,KAAK,CAAC,IAAI,CAAS,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC;gBACxD,CAAC;gBAEY,kCAAgB,GAA7B,UAA8B,GAAmB;;;4BAC/C,sBAAO,IAAI,OAAO,CAAiB,UAAC,OAAO,EAAE,MAAM;oCACjD,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE,qCAAoB,EAAE,EAAE,EAAE,UAAC,KAAK,EAAE,OAAuB;wCACzE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;4CACV,MAAM,CAAC,KAAK,CAAC,CAAC;wCAChB,CAAC;wCAAC,IAAI,CAAC,CAAC;4CACN,OAAO,CAAC,OAAO,CAAC,CAAC;wCACnB,CAAC;oCACH,CAAC,CAAC,CAAC;gCACL,CAAC,CAAC,EAAC;;;iBACJ;gBACH,cAAC;YAAD,CAAC,AAzGM,CAAc,KAAK;YACV,OAAI,GAAG,WAAY;YACnB,OAAI,GAAG,OAAO,CAAC,IAAK;eAuGlC;;IACJ,CAAC,CAAC;AACJ,CAAC;AA7GD,8BA6GC","sourcesContent":["import * as Joi from 'joi';\nimport * as assert from 'assert';\nimport chalk from 'chalk';\n\nimport { ICommandHandler } from './Command';\nimport { CommandMessage, commandMessageSchema } from './CommandMessage';\nimport { IEventHandler } from './Event';\nimport { options } from 'joi';\nimport { Injector } from './Injector';\nimport { IStore, Store } from './Store';\nimport { Logger } from './Logger';\nimport { InternalLogger } from './InternalLogger';\nimport { EventMessage, eventMessageSchema } from './EventMessage';\n\nconst pascalCase = require('pascal-case');\n\nexport interface AggregateOptions {\n  /**\n   * The name of the aggregate, should be written in PascalCase\n   *\n   * @since 1.0\n   */\n  name: string;\n\n  /**\n   * The event handlers to add tom this aggregate\n   *\n   * @since 1.0\n   */\n  eventHandlers: Array<{\n    _InstantiateEventHandler: (injector: Injector) => IEventHandler<any, any>;\n    new(...args: any[]): IEventHandler<any, any>;\n    Event: string\n  }>;\n\n  /**\n   * The command handlers to add to this aggregate\n   *\n   * @since 1.0\n   */\n  commandHandlers: Array<{\n    _InstantiateCommandHandler(injector: Injector): ICommandHandler<any, any>,\n    new(...args: any[]): ICommandHandler<any, any>;\n    Command: string\n  }>;\n  providers?: any[];\n}\n\n/**\n * Represents a aggregate instance\n *\n * @since 1.0.0\n */\nexport abstract class IAggregate {\n\n  public static Type: string;\n\n  /**\n   * The name of this aggregate\n   *\n   * @since 1.0.0\n   */\n  readonly name: string;\n\n  /**\n   * Returns a command based on the provided command message\n   *\n   * @since 1.0.0\n   *\n   * @param {CommandMessage} commandMessage The command message to convert to a command instance\n   * @returns {Promise<EventMessage<any>[]>} A new command instance\n   */\n  handleCommand: (commandMessage: CommandMessage) => Promise<void>;\n\n  getState: (aggregateId: string) => Promise<{version: number, state: any}>;\n\n  getEventNames: () => string[];\n}\n\nexport function Aggregate(options: AggregateOptions) {\n  return <T extends {new(...args: any[]): {}}>(Class: T): T => {\n    return class extends Class {\n      public static Type = 'Aggregate';\n      public static Name = options.name;\n      public name = options.name;\n\n      static _InstantiateAggregate(parentInjector: Injector): IAggregate {\n        assert(parentInjector);\n        const injector = parentInjector.newChildInjector();\n        injector.set({provide: Logger, useConstant: new InternalLogger(chalk.yellow(`${pascalCase(options.name)}Aggregate`))});\n        return new this(injector);\n      }\n\n      _injector: Injector;\n      _commandHandlers: Map<string, ICommandHandler<any, any>>;\n      _eventHandlers: Map<string, IEventHandler<any, any>>;\n      _store: IStore;\n      _logger: Logger;\n\n      constructor(...args: any[]) {\n        super(...(args[0] as Injector).args(Class));\n\n        this._injector = args[0];\n        this._injector.set({provide: Aggregate, useConstant: this});\n\n        this._commandHandlers = new Map(options.commandHandlers.map<[string, ICommandHandler<any, any>]>((cmd) => [cmd.Command, cmd._InstantiateCommandHandler(this._injector)]));\n        this._eventHandlers = new Map(options.eventHandlers.map<[string, IEventHandler<any, any>]>((cmd) => [cmd.Event, cmd._InstantiateEventHandler(this._injector)]));\n\n        this._logger = this._injector.get<Logger>(Logger);\n        this._store = this._injector.get<IStore>(Store);\n\n        this._logger.verbose(`Registered events:\\n  - ${Array.from(this._eventHandlers.keys()).join(',\\n  - ')}`);\n        this._logger.verbose(`Registered commands:\\n  - ${Array.from(this._commandHandlers.keys()).join(',\\n  - ')}`);\n      }\n\n      public async handleCommand(commandMessage: CommandMessage): Promise<void> {\n        const validatedCommandMessage = await this._validateCommand(commandMessage);\n        const handler = this._commandHandlers.get(validatedCommandMessage.command);\n        const stateResult = await this.getState(validatedCommandMessage.aggregateId);\n        if(handler) {\n          const events = await handler.handle(validatedCommandMessage, stateResult.state, stateResult.version);\n          if(!events || events.length <= 0) {\n            this._logger.error(`Command handler for command ${validatedCommandMessage.command} did not return any events. A command has to return at least one event!`);\n            throw Error('Internal Server Error');\n          }\n          // TODO: retry insert to store\n          await this.applyToState({state: stateResult.state, version: stateResult.version}, events);\n          await this._store.applyEvents(this.name, events);\n        } else {\n          this._logger.error(`Received a unknown command \"${validatedCommandMessage.command}\"`);\n          throw Error(`UnknownCommand: ${validatedCommandMessage.command}`);\n        }\n      }\n\n      public async applyToState(stateDef: {version: number, state: any}, events: EventMessage[]) {\n        const sortedEvents = events.sort((e1, e2) => e1.eventId - e2.eventId);\n        let state: any = stateDef.state;\n        let version = stateDef.version;\n        for(const event of sortedEvents) {\n          Joi.assert(event, eventMessageSchema);\n          if( state === null && event.eventId != 0 ){\n            throw new Error('State can not be null if this is not the initial event');\n          }\n          if( event.eventId != version + 1 ) {\n            throw new Error('Events are not applied in sequential order');\n          }\n          const handler = this._eventHandlers.get(event.event);\n          if(handler){\n            state = {\n              ...await handler._validateAndHandle(event, state)\n            };\n            version = event.eventId;\n          } else {\n            throw new Error(`Handler missing for event ${event.event}`)\n          }\n        }\n\n        return {version, state};\n      }\n\n      public async getState(aggregateId: string): Promise<{version: number, state: any}> {\n        const eventResult = await this._store.getEvents(this.name, aggregateId);\n        let state: any = null;\n        let version: number = -1;\n        if(eventResult.snapshot) {\n          state = eventResult.snapshot.state || state;\n          version = eventResult.snapshot.version || version;\n        }\n        return await this.applyToState({state, version}, eventResult.events);\n      }\n\n      public getEventNames(): string[] {\n        return Array.from<string>(this._eventHandlers.keys());\n      }\n\n      public async _validateCommand(cmd: CommandMessage): Promise<CommandMessage> {\n        return new Promise<CommandMessage>((resolve, reject) => {\n          Joi.validate(cmd, commandMessageSchema, {}, (error, command: CommandMessage) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(command);\n            }\n          });\n        });\n      }\n    };\n  };\n}\n"]}