{"version":3,"file":"Event.js","sourceRoot":"","sources":["../../src/Event.ts"],"names":[],"mappings":";;;;;;;;;;AACA,iDAAkE;AAElE,2BAA2B;AAE3B,qCAAkC;AAElC;;;;GAIG;AACH;CAOC;AAPD,sCAOC;AAOD;;;;;GAKG;AACH,sBAA6B,OAA4B;IACvD,MAAM,CAAC,CAAsC,KAAQ,EAAE,EAAE;QACvD,MAAM,MAAC,KAAM,SAAQ,KAAK;gBAWxB,YAAY,GAAG,IAAW;oBACxB,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;oBALzB,UAAK,GAAG,OAAO,CAAC,KAAK,CAAC;oBAM3B,IAAI,CAAC,OAAO,GAAI,IAAI,CAAC,CAAC,CAAc,CAAC,GAAG,CAAS,eAAM,CAAC,CAAC;gBAC3D,CAAC;gBAbD,MAAM,CAAC,wBAAwB,CAAC,cAAwB;oBACtD,MAAM,QAAQ,GAAG,cAAc,CAAC,gBAAgB,EAAE,CAAC;oBACnD,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC5B,CAAC;gBAcK,kBAAkB,CAAC,KAAwB,EAAE,KAAU;;wBAC3D,IAAI,MAAM,GAAG,iCAAkB,CAAC;wBAChC,EAAE,CAAA,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;4BAClB,MAAM,GAAG,iCAAkB,CAAC,IAAI,CAAC;gCAC/B,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE;6BACnC,CAAC,CAAC;wBACL,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,MAAM,GAAG,iCAAkB,CAAC,IAAI,CAAC;gCAC/B,OAAO,EAAE,GAAG,CAAC,GAAG,EAAE;6BACnB,CAAC,CAAC;wBACL,CAAC;wBACD,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;wBAC1B,EAAE,CAAA,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;4BACf,MAAM,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;wBACzC,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,sBAAsB,IAAI,CAAC,KAAK,wBAAwB,CAAC,CAAC;4BAC7E,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;wBACtC,CAAC;oBACH,CAAC;iBAAA;aACF;YAhCe,OAAI,GAAG,OAAQ;YACf,QAAK,GAAG,OAAO,CAAC,KAAM;eA+BpC;;IACJ,CAAC,CAAC;AACJ,CAAC;AAzCD,oCAyCC","sourcesContent":["import { options, Schema } from 'joi';\nimport { EventMessage, eventMessageSchema } from './EventMessage';\nimport { Injector } from './Injector';\nimport * as Joi from 'joi';\nimport { IAggregate } from './Aggregate';\nimport { Logger } from './Logger';\n\n/**\n * OBS: Needed until typescript supports decorator type extensions.\n *\n * @since 1.0.0\n */\nexport abstract class IEventHandler<T, R> {\n  public static _InstantiateEventHandler: (injector: Injector) => IEventHandler<any, any>;\n  public static Type: string;\n  public static Event: string;\n  public readonly event: string;\n  public abstract handle(event: EventMessage<T>, state: R): Promise<R>;\n  _validateAndHandle: (event: EventMessage<T>, state: R) => Promise<R>;\n}\n\nexport interface EventHandlerOptions {\n  event: string;\n  schema?: Schema;\n}\n\n/**\n * Creates a new event.\n *\n * @since 1.0.0\n * @returns {IEventHandler<any>} A decorated class that implements IEvent\n */\nexport function EventHandler(options: EventHandlerOptions) {\n  return <T extends {new(...args: any[]): {}}>(Class: T) => {\n    return class extends Class {\n      static _InstantiateEventHandler(parentInjector: Injector): IEventHandler<any, any> {\n        const injector = parentInjector.newChildInjector();\n        return new this(injector);\n      }\n      public static Type = 'Event';\n      public static Event = options.event;\n      public event = options.event;\n\n      _logger: Logger;\n\n      constructor(...args: any[]) {\n        super(...args[0].args(Class));\n        this._logger = (args[0] as Injector).get<Logger>(Logger);\n      }\n\n      handle: (event: EventMessage<any>, state: any) => Promise<any>;\n\n      async _validateAndHandle(event: EventMessage<any>, state: any): Promise<any> {\n        let schema = eventMessageSchema;\n        if(options.schema) {\n          schema = eventMessageSchema.keys({\n            content: options.schema.required()\n          });\n        } else {\n          schema = eventMessageSchema.keys({\n            content: Joi.any()\n          });\n        }\n        Joi.assert(event ,schema);\n        if(this.handle) {\n          return await this.handle(event, state);\n        } else {\n          this._logger.error(`The event handler \"${this.event}\" has no handle method`);\n          throw new Error('No handle method');\n        }\n      }\n    };\n  };\n}\n"]}