{"version":3,"file":"Aggregate.js","sourceRoot":"","sources":["../../src/Aggregate.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Joi from 'joi';\nimport * as assert from 'assert';\nimport chalk from 'chalk';\n\nimport { ICommandHandler } from './Command';\nimport { CommandMessage, commandMessageSchema } from './CommandMessage';\nimport { IEventHandler } from './Event';\nimport { options } from 'joi';\nimport { Injector } from './Injector';\nimport { IStore, Store } from './Store';\nimport { Logger } from './Logger';\nimport { InternalLogger } from './InternalLogger';\nimport { EventMessage, eventMessageSchema } from './EventMessage';\n\nconst pascalCase = require('pascal-case');\n\nexport interface AggregateOptions {\n  /**\n   * The name of the aggregate, should be written in PascalCase\n   *\n   * @since 1.0\n   */\n  name: string;\n\n  /**\n   * The event handlers to add tom this aggregate\n   *\n   * @since 1.0\n   */\n  eventHandlers: Array<{\n    _InstantiateEventHandler: (injector: Injector) => IEventHandler<any, any>;\n    new(...args: any[]): IEventHandler<any, any>;\n    Event: string\n  }>;\n\n  /**\n   * The command handlers to add to this aggregate\n   *\n   * @since 1.0\n   */\n  commandHandlers: Array<{\n    _InstantiateCommandHandler(injector: Injector): ICommandHandler<any, any>,\n    new(...args: any[]): ICommandHandler<any, any>;\n    Command: string\n  }>;\n  providers?: any[];\n}\n\n/**\n * Represents a aggregate instance\n *\n * @since 1.0.0\n */\nexport abstract class IAggregate {\n\n  public static Type: string;\n\n  /**\n   * The name of this aggregate\n   *\n   * @since 1.0.0\n   */\n  readonly name: string;\n\n  /**\n   * Returns a command based on the provided command message\n   *\n   * @since 1.0.0\n   *\n   * @param {CommandMessage} commandMessage The command message to convert to a command instance\n   * @returns {Promise<EventMessage<any>[]>} A new command instance\n   */\n  handleCommand: (commandMessage: CommandMessage) => Promise<void>;\n\n  getState: (aggregateId: string) => Promise<{version: number, state: any}>;\n\n  getEventNames: () => string[];\n}\n\nexport function Aggregate(options: AggregateOptions) {\n  return <T extends {new(...args: any[]): {}}>(Class: T): T => {\n    return class extends Class {\n      public static Type = 'Aggregate';\n      public static Name = options.name;\n      public name = options.name;\n\n      static _InstantiateAggregate(parentInjector: Injector): IAggregate {\n        assert(parentInjector);\n        const injector = parentInjector.newChildInjector();\n        injector.set({provide: Logger, useConstant: new InternalLogger(chalk.yellow(`${pascalCase(options.name)}Aggregate`))});\n        return new this(injector);\n      }\n\n      _injector: Injector;\n      _commandHandlers: Map<string, ICommandHandler<any, any>>;\n      _eventHandlers: Map<string, IEventHandler<any, any>>;\n      _store: IStore;\n      _logger: Logger;\n\n      constructor(...args: any[]) {\n        super(...(args[0] as Injector).args(Class));\n\n        this._injector = args[0];\n        this._injector.set({provide: Aggregate, useConstant: this});\n\n        this._commandHandlers = new Map(options.commandHandlers.map<[string, ICommandHandler<any, any>]>((cmd) => [cmd.Command, cmd._InstantiateCommandHandler(this._injector)]));\n        this._eventHandlers = new Map(options.eventHandlers.map<[string, IEventHandler<any, any>]>((cmd) => [cmd.Event, cmd._InstantiateEventHandler(this._injector)]));\n\n        this._logger = this._injector.get<Logger>(Logger);\n        this._store = this._injector.get<IStore>(Store);\n\n        this._logger.verbose(`Registered events:\\n  - ${Array.from(this._eventHandlers.keys()).join(',\\n  - ')}`);\n        this._logger.verbose(`Registered commands:\\n  - ${Array.from(this._commandHandlers.keys()).join(',\\n  - ')}`);\n      }\n\n      public async handleCommand(commandMessage: CommandMessage): Promise<void> {\n        const validatedCommandMessage = await this._validateCommand(commandMessage);\n        const handler = this._commandHandlers.get(validatedCommandMessage.command);\n        const stateResult = await this.getState(validatedCommandMessage.aggregateId);\n        if(handler) {\n          const events = await handler.handle(validatedCommandMessage, stateResult.state, stateResult.version);\n          if(!events || events.length <= 0) {\n            this._logger.error(`Command handler for command ${validatedCommandMessage.command} did not return any events. A command has to return at least one event!`);\n            throw Error('Internal Server Error');\n          }\n          // TODO: retry insert to store\n          await this.applyToState({state: stateResult.state, version: stateResult.version}, events);\n          await this._store.applyEvents(this.name, events);\n        } else {\n          this._logger.error(`Received a unknown command \"${validatedCommandMessage.command}\"`);\n          throw Error(`UnknownCommand: ${validatedCommandMessage.command}`);\n        }\n      }\n\n      public async applyToState(stateDef: {version: number, state: any}, events: EventMessage[]) {\n        const sortedEvents = events.sort((e1, e2) => e1.eventId - e2.eventId);\n        let state: any = stateDef.state;\n        let version = stateDef.version;\n        for(const event of sortedEvents) {\n          Joi.assert(event, eventMessageSchema);\n          if( state === null && event.eventId != 0 ){\n            throw new Error('State can not be null if this is not the initial event');\n          }\n          if( event.eventId != version + 1 ) {\n            throw new Error('Events are not applied in sequential order');\n          }\n          const handler = this._eventHandlers.get(event.event);\n          if(handler){\n            state = {\n              ...await handler._validateAndHandle(event, state)\n            };\n            version = event.eventId;\n          } else {\n            throw new Error(`Handler missing for event ${event.event}`)\n          }\n        }\n\n        return {version, state};\n      }\n\n      public async getState(aggregateId: string): Promise<{version: number, state: any}> {\n        const eventResult = await this._store.getEvents(this.name, aggregateId);\n        let state: any = null;\n        let version: number = -1;\n        if(eventResult.snapshot) {\n          state = eventResult.snapshot.state || state;\n          version = eventResult.snapshot.version || version;\n        }\n        return await this.applyToState({state, version}, eventResult.events);\n      }\n\n      public getEventNames(): string[] {\n        return Array.from<string>(this._eventHandlers.keys());\n      }\n\n      public async _validateCommand(cmd: CommandMessage): Promise<CommandMessage> {\n        return new Promise<CommandMessage>((resolve, reject) => {\n          Joi.validate(cmd, commandMessageSchema, {}, (error, command: CommandMessage) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(command);\n            }\n          });\n        });\n      }\n    };\n  };\n}\n"]}